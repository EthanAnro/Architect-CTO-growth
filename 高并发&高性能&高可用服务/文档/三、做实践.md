三、做实践
=============
- [三、做实践](#三、做实践)
    - [1. 高性能的实践方案](#1高性能的实践方案)
      - [1.1 缓存](#1-1缓存)
      - [1.2 数据库](#1-2数据库)
      - [1.3 流量治理](#1-3流量治理)
      - [1.4 程序及架构](#1-4程序及架构)
    - [2. 高可用的实践方案](#2高可用的实践方案)
      - [2.1 服务及流量治理](#2-1服务及流量治理)
      - [2.2 运维及监控](#2-2运维及监控)
    - [3. 高扩展的实践方案](#3高扩展的实践方案)
      - [3.1 业务层的拆分：微服务架构](#3-1业务层的拆分：微服务架构)
        - [3.1.1 以领域驱动设计（DDD）来进行业务维度的微服务拆分](#3-1-1以领域驱动设计（-ddd）来进行业务维度的微服务拆分)
        - [3.1.2 微服务合理的分层架构](#3-1-2微服务合理的分层架构)
        - [3.1.3 微服务框架（生态）的选择](#3-1-3微服务框架（生态）的选择)
      - [3.2 数据层的拆分](#3-2数据层的拆分)
    - [4. 扩展实践：云原生技术体系](#4扩展实践：云原生技术体系)


### 1. 高性能的实践方案
#### 1.1 缓存
- 多级缓存：使用CDN、本地缓存、分布式缓存等缓存静态数据或更新频率低的动态数据。同时注意对缓存场景中的热点key、缓存雪崩（缓存穿透、缓存击穿、缓存并发）造成的数据一致性等问题的处理。
- 缓存预热：通过异步任务提前预热数据到本地缓存或者分布式缓存中。
- 预计算：比如非实时个性化推荐场景，可以提前计算好的推荐页面缓存起来，用户登录时直接获取。
#### 1.2 数据库
- 关系型数据库的分库分表和索引优化。
- 借助搜索引擎技术（如Elasticsearch）解决复杂查询问题。
- 选用新型高性能分布式数据库的使用，比如HBase、 ClickHouse等。
#### 1.3 流量治理
- 集群部署，通过负载均衡机制进行自动缩扩容，减少单服务压力。
- 对流量进行削峰填谷，通过MQ（消息队列）承接流量。
#### 1.4 程序及架构
- 并发处理，通过多线程将串行逻辑并行化。
- 异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。
- 减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口调用。
- 减少网络传输或IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、减少缓存key的大小、压缩缓存value等。
- 各种池化技术的使用，池大小的合理设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。
- 程序逻辑优化，采用更高效的算法。
- 锁选择，读多写少的场景用乐观锁，或者考虑通过更小颗粒度分段锁的方式减少锁冲突。
- JVM优化，GC算法的选择等，尽可能减少GC频率和耗时。

### 2. 高可用的实践方案
#### 2.1 服务及流量治理
- 对于无状态服务：当前节点出现故障时迅速利用负载均衡组件或服务治理框架切换至另一个可用节点。
- 对于有状态服务：采用主备或者热备方案实施故障节点切换。比如MySQL的主从切换、Redis的哨兵与Cluster集群模式、MongoDB的副本集模式与Sharding 模式。
- 接口层面：合理的超时设置、重试策略和幂等设计。
- 服务熔断降级：为保证核心服务高可用，可牺牲非核心服务，在必要时进行熔断处理。
- 限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。
> 对于服务降级与限流，注意客户端也需要进行相应设计，尽量降低对用户体验的影响
- MQ（消息队列）：消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。

> 以上内容可能涉及的组件及技术框架：
> - 负载均衡组件：如nginx、公有云弹性负载服务等；
> - 服务治理框架：如Dubbo、Spring Cloud、K8s + Service Mesh（Istio）

#### 2.2 运维及监控
- 故障注入与灾备演练：刻意制造系统故障，测试系统高可用能力。
- 降低发布风险：蓝绿部署、滚动部署、金丝雀（灰度）发布。
- 监控告警：搭建基础设施和服务应用级别全方位的监控和告警体系，如CPU、内存、磁盘、网络的监控告警，以及Web服务器、JVM、数据库、各类中间件的监控告警和业务应用指标的监控告警。

### 3. 高扩展的实践方案
#### 3.1 业务层的拆分：微服务架构
##### 3.1.1 以领域驱动设计（DDD）来进行业务维度的微服务拆分
1. **业务中台领域建模**

    根据流程或功能边界，初步划分子域边界，并将子域分为通用子域和核心子域。在子域内开展事件风暴，找出界限上下文边界，完成领域建模。
2. **业务单元化设计**

    以领域建模为基准进行单元化设计，向上建设微前端实现领域模型的前端页面逻辑，向下建设微服务实现领域模型的领域逻辑。将微服务和微前端组合为业务单元，完成集成、测试和部署。
3. **构建企业级前台应用**

    根据企业级业务流程，组合和编排不同业务单元的微前端页面，实现不同业务单元的业务能力在企业级前台的业务联通和融合。
4. **中台和后台的解耦**

    采用领域事件驱动机制实现中台微服务之间，以及中台与后台之间业务逻辑的解耦，实现数据的融合。
##### 3.1.2 微服务合理的分层架构 
![微服务分层架构](image/微服务分层架构.png)
<p align="center">图 微服务分层架构</p>

> 参考书籍： 《中台架构与实现——基于DDD和微服务》，作者 欧创新…，出版社 机械工业出版社

##### 3.1.3 微服务框架（生态）的选择
**Dubbo、Spring Cloud、K8s + Service Mesh的对比**
> 以下总结大部分摘写自 CSDN用户：chentian114 的文章[《技术栈选型之微服务公共关注点及Dubbo、Spring Cloud和K8s横向比对》](https://blog.csdn.net/chentian114/article/details/123650963)，我们团队亲自实践的是从Dubbo转向K8s+ServiceMesh（Istio）的技术生态。

- **技术实践对比**

| &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; | Dubbo  | SpringCloud | K8s + ServiceMesh |
|  ----  | ----  | ----  | ----  |
| **服务发现和LB** | ZK/Nacos + client | Eureka + Ribbon | K8s service| 
| **API网关** | N/A | Zuul/Spring Cloud Gateway | Ingress Gateway | 
| **配置管理** | Diamond/Nacos | Spring Cloud Config | ConfigMaps/Secrets | 
| **熔断限流** | Sentinel | Hystrix | HealthCheck/Probe/ServiceMesh | 
| **日志监控** | ELK | ELK | EFK | 
| **Metrics监控** | Dubbo Admin/Monitor | Actuator/MicroMeter+Promethus | Heapster+Promethus | 
| **调用链监控** | N/A | Spring Cloud Sleuth/Zipkin | Jaeger/Zipkin | 
| **应用打包** | Jar/War | Uber Jar/War | Docker Image/Helm | 
| **服务语言框架** | Dubbo RPC + Java  | Spring（Boot）REST + Java |框架、语言无关 | 
| **发布和调度** | N/A | N/A | kube-Scheduler |
| **自动伸缩和自愈** | N/A | N/A | kube-Scheduler/AutoScaler |
| **进程隔离** | N/A | N/A | Docker/Pod |
| **环境管理** | N/A | N/A | Namespace/Authorization |
| **资源配置** | N/A | N/A | CPU/Mem limit，Namespace Quotas |
| **流量治理** | N/A | N/A | ServiceMesh |

- **生态优劣势对比**

|  &emsp;&emsp;&emsp;  | Dubbo  | SpringCloud | K8s + ServiceMesh |
|  ----  | ----  | ----  | ----  |
| **优势** | 阿里背书，成熟稳定，RPC高性能，流量治理方面较细致 | Netflix/Pivotal背书，社区活跃，开发体验好，抽象和组件化好 | 谷歌、CNCF背书，抽象和组件化好，微服务生态统一且完整，支持异构语言，社区活跃 | 
| **不足** | 技术较老、更新慢，SDK的耦合度高，仅支持Java技术栈，社区活跃度较低 | 仅支持Java技术栈，运行耗资源 | 技术门槛较高，ServiceMesh的sidecar机制有一定的性能损耗 | 

#### 3.2 数据层的拆分
按照业务维度做垂直拆分，按照数据特征维度做水平拆分（分库分表）

### 4. 扩展实践：云原生技术体系
>请参见同文件夹文档(../../云原生技术体系/云原生技术体系（Guides）.md)
